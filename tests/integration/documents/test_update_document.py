"""Team Copilot Tests - Integration Tests - Documents - Update Document."""

from uuid import uuid4
from datetime import datetime, timezone
from io import BytesIO
from unittest.mock import patch, call

from dateutil.parser import parse

from fastapi import FastAPI, status
from fastapi.testclient import TestClient

from team_copilot.core.auth import get_staff_user
from team_copilot.models.data import User, Document, DocumentStatus

from tests.integration import raise_not_authorized_exc


def test_update_documnt(
    app: FastAPI,
    test_client: TestClient, 
    test_staff_user: User,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint.

    Args:
        app (FastAPI): FastAPI application.
        test_client (TestClient): FastAPI test client.
        test_staff_user (User): Mock enabled staff user.
        test_pdf_file (BytesIO): PDF file mock.
    """
    # Simulate the injected dependency
    app.dependency_overrides[get_staff_user] = lambda: test_staff_user

    doc_id = uuid4()
    now = datetime.now(timezone.utc)

    # Simulate an existing document
    doc = Document(
        id=doc_id,
        name="Document",
        status=DocumentStatus.COMPLETED,
        created_at=now,
        updated_at=now,
    )

    # Request data
    req_data = {"name": "New Document"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    with (
        patch(
            "team_copilot.routers.documents.get_doc",
            return_value=None,
        ) as mock_get_doc,
        patch("team_copilot.routers.documents.save_document") as mock_save_doc,
        patch(
            "team_copilot.routers.documents.get_document_file_path",
            return_value="/tmp/test.pdf",
        ) as mock_get_path,
        patch("team_copilot.routers.documents.upload_file") as mock_upload_file,
        patch("team_copilot.routers.documents.process_document") as mock_proc_doc,
    ):
        # Simulate the returned values of the "get_doc" function
        mock_get_doc.side_effect = [doc, None]

        # Configure the "save_document" mock to simulate the fields of the document that
        # are generated by the database server when updating a document ("updated_at").
        def side_effect(d: Document):
            d.updated_at = now

        mock_save_doc.side_effect = side_effect

        # Make HTTP request
        response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

        # Check response
        assert response.status_code == status.HTTP_202_ACCEPTED

        res_data = response.json()
        assert len(res_data) == 2

        assert (
            res_data["message"] ==
            f"Document {doc.id} ({doc.name}) updated and scheduled for processing."
        )

        data = res_data["data"]
        assert len(data) == 5

        assert data["id"] == str(doc.id)
        assert data["name"] == doc.name
        assert data["status"] == doc.status
        assert parse(data["created_at"]) == doc.created_at
        assert parse(data["updated_at"]) == doc.updated_at

        # Check function calls
        mock_get_doc.assert_has_calls([
            call(id=doc_id),
            call(name=req_data["name"]),
        ])

        mock_save_doc.assert_called_once()
        mock_get_path.assert_called_once_with(doc_id)
        mock_upload_file.assert_called_once()
        mock_proc_doc.assert_called_once()

    app.dependency_overrides.clear()


def test_update_document_unauthenticated(
    test_client: TestClient,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint for an unauthenticated user.

    Args:
        test_client (TestClient): FastAPI test client.
        test_pdf_file (BytesIO): PDF file mock.
    """
    doc_id = uuid4()

    # Request data
    req_data = {"name": "New Document"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    # Make HTTP request
    response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

    # Check response
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    res_data = response.json()

    assert len(res_data) == 3
    assert res_data["message"] == "Authentication error."
    assert res_data["count"] == 1

    data = res_data["data"]
    assert len(data) == 1
    assert data[0]["id"] == "authentication"
    assert data[0]["message"] == "Not authenticated"


def test_update_document_unauthorized(
    app: FastAPI,
    test_client: TestClient,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint for an unauthorized user.

    Args:
        app (FastAPI): FastAPI application.
        test_client (TestClient): FastAPI test client.
        test_pdf_file (BytesIO): PDF file mock.
    """
    # Simulate the injected dependency
    app.dependency_overrides[get_staff_user] = raise_not_authorized_exc

    doc_id = uuid4()

    # Request data
    req_data = {"name": "New Document"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    # Make HTTP request
    response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

    # Check response
    assert response.status_code == status.HTTP_403_FORBIDDEN

    res_data = response.json()
    assert len(res_data) == 3
    assert res_data["message"] == "Authorization error."
    assert res_data["count"] == 1

    data = res_data["data"]
    assert len(data) == 1
    assert data[0]["id"] == "authorization"
    assert data[0]["message"] == "Not authorized"

    app.dependency_overrides.clear()


def test_update_document_not_found(
    app: FastAPI,
    test_client: TestClient,
    test_staff_user: User,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint for a non-existing document.

    Args:
        app (FastAPI): FastAPI application.
        test_client (TestClient): FastAPI test client.
        test_staff_user (User): Mock enabled staff user.
        test_pdf_file (BytesIO): PDF file mock.
    """
    # Simulate the injected dependency
    app.dependency_overrides[get_staff_user] = lambda: test_staff_user

    doc_id = uuid4()

    # Request data
    req_data = {"name": "New Document"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    with patch(
        "team_copilot.routers.documents.get_doc",
        return_value=None,
    ) as mock_get_doc:
        # Make HTTP request
        response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

        # Check response
        assert response.status_code == status.HTTP_404_NOT_FOUND

        res_data = response.json()
        assert len(res_data) == 3

        assert res_data["message"] == "Error."
        assert res_data["count"] == 1
        assert res_data["data"][0]["id"] == "error"
        assert res_data["data"][0]["message"] == f"Document {doc_id} not found."

        # Check function calls
        mock_get_doc.assert_called_once_with(id=doc_id)

    app.dependency_overrides.clear()


def test_update_document_exists(
    app: FastAPI,
    test_client: TestClient,
    test_staff_user: User,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint when a document with the same name already
    exists.

    Args:
        app (FastAPI): FastAPI application.
        test_client (TestClient): FastAPI test client.
        test_staff_user (User): Mock enabled staff user.
        test_pdf_file (BytesIO): PDF file mock.
    """
    # Simulate the injected dependency
    app.dependency_overrides[get_staff_user] = lambda: test_staff_user

    doc_id = uuid4()
    now = datetime.now(timezone.utc)

    # Simulate an existing document
    doc = Document(
        id=doc_id,
        name="Document 1",
        status=DocumentStatus.COMPLETED,
        created_at=now,
        updated_at=now,
    )

    # Simulate another existing document
    other_doc = Document(
        id=uuid4(),
        name="Document 2",
        status=DocumentStatus.COMPLETED,
        created_at=now,
        updated_at=now,
    )

    # Request data
    req_data = {"name": "Document 2"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    with patch("team_copilot.routers.documents.get_doc") as mock_get_doc:
        # Simulate the returned values of the "get_doc" function
        mock_get_doc.side_effect = [doc, other_doc]

        # Make HTTP request
        response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

        # Check response
        assert response.status_code == status.HTTP_409_CONFLICT

        res_data = response.json()
        assert len(res_data) == 3

        assert res_data["message"] == "Error."
        assert res_data["count"] == 1

        data = res_data["data"]
        assert len(data) == 1

        assert data[0]["id"] == "error"
        assert data[0]["message"] == "A document with the same name already exists."

        # Check function calls
        mock_get_doc.assert_has_calls([
            call(id=doc_id),
            call(name=req_data["name"]),
        ])

    app.dependency_overrides.clear()
