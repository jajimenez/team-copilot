"""Team Copilot Tests - Integration Tests - Documents - Update Document."""

from uuid import uuid4
from datetime import datetime, timezone
from io import BytesIO
from unittest.mock import patch, call, MagicMock

from dateutil.parser import parse

from fastapi import FastAPI, status
from fastapi.testclient import TestClient

from team_copilot.core.auth import get_staff_user
from team_copilot.models.data import User, Document, DocumentStatus

from tests.integration import raise_not_authorized_exc


@patch("team_copilot.routers.documents.get_doc", return_value=None)
@patch("team_copilot.routers.documents.save_document")
@patch(
    "team_copilot.routers.documents.get_document_file_path",
    return_value="/tmp/test.pdf",
)
@patch("team_copilot.routers.documents.upload_file")
@patch("team_copilot.routers.documents.process_document")
def test_update_documnt(
    mock_process_document: MagicMock,
    mock_upload_file: MagicMock,
    mock_get_document_file_path: MagicMock,
    mock_save_document: MagicMock,
    mock_get_doc: MagicMock,
    app: FastAPI,
    test_client: TestClient, 
    test_staff_user: User,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint.

    Args:
        mock_process_document (MagicMock): Mock object for the "process_document"
            function.
        mock_upload_file (MagicMock): Mock object for the "upload_file" function.
        mock_get_document_file_path (MagicMock): Mock object for the
            "get_document_file_path" function.
        mock_save_document (MagicMock): Mock object for the "save_document" function.
        mock_get_doc (MagicMock): Mock object for the "get_doc" function.
        app (FastAPI): FastAPI application.
        test_client (TestClient): FastAPI test client.
        test_staff_user (User): Test enabled staff user.
        test_pdf_file (BytesIO): Test PDF file.
    """
    # Simulate injected dependencies
    app.dependency_overrides[get_staff_user] = lambda: test_staff_user

    # Simulate an existing document
    doc_id = uuid4()
    now = datetime.now(timezone.utc)

    doc = Document(
        id=doc_id,
        name="Document",
        status=DocumentStatus.COMPLETED,
        created_at=now,
        updated_at=now,
    )

    # Request data
    req_data = {"name": "New Document"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    # Simulate the returned values of the "get_doc" function
    mock_get_doc.side_effect = [doc, None]

    # Configure the "save_document" mock to simulate the fields of the document that
    # are generated by the database server when updating a document ("updated_at").
    def side_effect(d: Document):
        d.updated_at = now

    mock_save_document.side_effect = side_effect

    # Make HTTP request
    response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

    # Check response
    assert response.status_code == status.HTTP_202_ACCEPTED

    res_data = response.json()
    assert len(res_data) == 2

    assert (
        res_data["message"] ==
        f"Document {doc.id} ({doc.name}) updated and scheduled for processing."
    )

    data = res_data["data"]
    assert len(data) == 5

    assert data["id"] == str(doc.id)
    assert data["name"] == doc.name
    assert data["status"] == doc.status
    assert parse(data["created_at"]) == doc.created_at
    assert parse(data["updated_at"]) == doc.updated_at

    # Check function calls
    mock_get_doc.assert_has_calls([
        call(id=doc_id),
        call(name=req_data["name"]),
    ])

    mock_save_document.assert_called_once()
    mock_get_document_file_path.assert_called_once_with(doc_id)
    mock_upload_file.assert_called_once()
    mock_process_document.assert_called_once()

    # Clear simulated injected dependencies
    app.dependency_overrides.clear()


def test_update_document_unauthenticated(
    test_client: TestClient,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint for an unauthenticated user.

    Args:
        test_client (TestClient): FastAPI test client.
        test_pdf_file (BytesIO): Test PDF file.
    """
    # Simulate a document ID
    doc_id = uuid4()

    # Request data
    req_data = {"name": "New Document"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    # Make HTTP request
    response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

    # Check response
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    res_data = response.json()

    assert len(res_data) == 3
    assert res_data["message"] == "Authentication error."
    assert res_data["count"] == 1

    data = res_data["data"]
    assert len(data) == 1
    assert data[0]["id"] == "authentication"
    assert data[0]["message"] == "Not authenticated"


def test_update_document_unauthorized(
    app: FastAPI,
    test_client: TestClient,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint for an unauthorized user.

    Args:
        app (FastAPI): FastAPI application.
        test_client (TestClient): FastAPI test client.
        test_pdf_file (BytesIO): Test PDF file.
    """
    # Simulate injected dependencies
    app.dependency_overrides[get_staff_user] = raise_not_authorized_exc

    # Simulate a document ID
    doc_id = uuid4()

    # Request data
    req_data = {"name": "New Document"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    # Make HTTP request
    response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

    # Check response
    assert response.status_code == status.HTTP_403_FORBIDDEN

    res_data = response.json()
    assert len(res_data) == 3
    assert res_data["message"] == "Authorization error."
    assert res_data["count"] == 1

    data = res_data["data"]
    assert len(data) == 1
    assert data[0]["id"] == "authorization"
    assert data[0]["message"] == "Not authorized"

    # Clear simulated injected dependencies
    app.dependency_overrides.clear()


@patch("team_copilot.routers.documents.get_doc", return_value=None)
def test_update_document_not_found(
    mock_get_doc: MagicMock,
    app: FastAPI,
    test_client: TestClient,
    test_staff_user: User,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint for a non-existing document.

    Args:
        mock_get_doc (MagicMock): Mock object for the "get_doc" function.
        app (FastAPI): FastAPI application.
        test_client (TestClient): FastAPI test client.
        test_staff_user (User): Test enabled staff user.
        test_pdf_file (BytesIO): Test PDF file.
    """
    # Simulate injected dependencies
    app.dependency_overrides[get_staff_user] = lambda: test_staff_user

    # Simulate the document ID of a non-existing document
    doc_id = uuid4()

    # Request data
    req_data = {"name": "New Document"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    # Make HTTP request
    response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

    # Check response
    assert response.status_code == status.HTTP_404_NOT_FOUND

    res_data = response.json()
    assert len(res_data) == 3

    assert res_data["message"] == "Error."
    assert res_data["count"] == 1
    assert res_data["data"][0]["id"] == "error"
    assert res_data["data"][0]["message"] == f"Document {doc_id} not found."

    # Check function calls
    mock_get_doc.assert_called_once_with(id=doc_id)

    # Clear simulated injected dependencies
    app.dependency_overrides.clear()


@patch("team_copilot.routers.documents.get_doc")
def test_update_document_exists(
    mock_get_doc: MagicMock,
    app: FastAPI,
    test_client: TestClient,
    test_staff_user: User,
    test_pdf_file: BytesIO,
):
    """Test the "update_document" endpoint when a document with the same name already
    exists.

    Args:
        mock_get_doc (MagicMock): Mock object for the "get_doc" function.
        app (FastAPI): FastAPI application.
        test_client (TestClient): FastAPI test client.
        test_staff_user (User): Test enabled staff user.
        test_pdf_file (BytesIO): Test PDF file.
    """
    # Simulate injected dependencies
    app.dependency_overrides[get_staff_user] = lambda: test_staff_user

    # Simulate an existing document to update
    doc_id = uuid4()
    now = datetime.now(timezone.utc)

    doc = Document(
        id=doc_id,
        name="Document 1",
        status=DocumentStatus.COMPLETED,
        created_at=now,
        updated_at=now,
    )

    # Simulate another existing document
    other_doc = Document(
        id=uuid4(),
        name="Document 2",
        status=DocumentStatus.COMPLETED,
        created_at=now,
        updated_at=now,
    )

    # Request data
    req_data = {"name": "Document 2"}
    files = {"file": ("document.pdf", test_pdf_file, "application/pdf")}

    # Simulate the returned values of the "get_doc" function
    mock_get_doc.side_effect = [doc, other_doc]

    # Make HTTP request
    response = test_client.put(f"/documents/{doc_id}", data=req_data, files=files)

    # Check response
    assert response.status_code == status.HTTP_409_CONFLICT

    res_data = response.json()
    assert len(res_data) == 3

    assert res_data["message"] == "Error."
    assert res_data["count"] == 1

    data = res_data["data"]
    assert len(data) == 1

    assert data[0]["id"] == "error"
    assert data[0]["message"] == "A document with the same name already exists."

    # Check function calls
    mock_get_doc.assert_has_calls([call(id=doc_id), call(name=req_data["name"])])

    # Clear simulated injected dependencies
    app.dependency_overrides.clear()
